<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0050)http://algolist.manual.ru/ds/basic/simple_list.php -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" ""><HTML><HEAD><META 
content="IE=5.0000" http-equiv="X-UA-Compatible">
         <TITLE>Реализация односвязного и двусвязного списков</TITLE> 
<META http-equiv="Content-Type" content="text/html; charset=windows-1251">
<STYLE type="text/css">
body { position: relative; padding-bottom: 100px; }
#lrek { position: absolute; width:100%; bottom: 0; font-size: 10px }
#lrek * { font-size: 10px;}
a,.out {text-decoration: none; cursor:pointer;color:#06c}
a:hover,.out:hover {text-decoration: underline; color: #ff6600;cursor:pointer }
h2 {font-size:14pt; font-family:sans-serif; font-weight:bold }
pre {font-size:12pt}
.source {font-size:12pt; color: #666699}
.l2 {font-size:13pt}
.l3 {font-size:12pt}
a,.out, p, td { font-size: 13pt }
</STYLE>
 
<META name="keywords" content="алгоритм, построение, создание, написание, исходник, программа, определение, метод, вычисление, поиск, нахождение, реализация, описание, структуры данных, словари, хэширование, индексация, хранение, быстрый, оптимальный, вставка, удаление, замена, поиск, абстрактный, тип, список, односвязный, двусвязный, реализация, Паскаль, пример"> 
<META name="description" content="Структуры данных и хэширование. Введение в абстрактные структуры. Реализация односвязного и двусвязного списков."> 
<META name="copyright" content="Основной контент - Кантор Илья, дизайн - Владимир Городулин, основа движка и разнообразная помощь - Алексей Фортуна"> 
<META name="GENERATOR" content="MSHTML 11.00.9600.16668"></HEAD> 
<BODY topmargin="0" leftmargin="0" bgcolor="#eeeeee" link="#0066cc" vlink="#0066cc" 
marginwidth="0" marginheight="0">
<STYLE>
#logotable img { border-style:none }
</STYLE>
 <!-- logo header ... --> 
<TABLE width="100%" id="logotable" border="0" cellspacing="0" cellpadding="0">
  <TBODY>
  <TR>
    <TD width="100%" bgcolor="#dd6e00" colspan="2"><A href="http://algolist.manual.ru/"><IMG 
      width="313" height="41" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/mlogo1.gif"></A></TD></TR>
  <TR>
    <TD bgcolor="#ffffff" colspan="2"><A 
      href="http://algolist.manual.ru/"><IMG width="313" height="3" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/mlogo2.gif"></A></TD></TR>
  <TR>
    <TD><A href="http://algolist.manual.ru/"><IMG width="313" height="33" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/mlogo3.gif"></A></TD>
    <TD width="100%" background="Реализация%20односвязного%20и%20двусвязного%20списков_files/mgrad.gif" 
    nowrap="" bgcolor="#fe7e00">
      <TABLE align="right" border="0" cellspacing="3" cellpadding="0">
        <TBODY>
        <TR valign="middle"><!--

      <FORM NAME="search_form" METHOD=GET ACTION="/cgi-bin/search.cgi">
      <td><INPUT TYPE="text" NAME="q" SIZE=30 VALUE="" class="inputfield"></td>
      <td><INPUT TYPE="image" src="/img/search.gif" width=68 height=19 border=0 onclick="this.blur()"></td>
      </FORM>

--> 
                </TR></TBODY></TABLE></TD></TR>
  <TR>
    <TD bgcolor="#ffffff" colspan="2"><IMG width="1" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"></TD></TR></TBODY></TABLE><!-- ...logo header --> <!--Rating@Mail.ru COUNTER-->
<SCRIPT language="JavaScript" type="text/javascript"><!--
d=document;var a='';a+=';r='+escape(d.referrer)
js=10//--></SCRIPT>

<SCRIPT language="JavaScript1.1" type="text/javascript"><!--
a+=';j='+navigator.javaEnabled()
js=11//--></SCRIPT>

<SCRIPT language="JavaScript1.2" type="text/javascript"><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></SCRIPT>

<SCRIPT language="JavaScript1.3" type="text/javascript"><!--
js=13//--></SCRIPT>

<SCRIPT language="JavaScript" type="text/javascript"><!--
d.write('<IMG src="http://d8.c7.bf.a0.top.list.ru/counter'+
'?id=1013908;js='+js+a+';rand='+Math.random()+
'" height=1 width=1/>')
if(11<js)d.write('<'+'!-- ')//--></SCRIPT>
<NOSCRIPT>&lt;img src="http://d8.c7.bf.a0.top.list.ru/counter?js=na;id=1013908"
 height=1 width=1 alt=""/&gt;</NOSCRIPT>
<SCRIPT language="JavaScript" type="text/javascript"><!--
if(11<js)d.write('--'+'>')//--></SCRIPT>
<!--/COUNTER--> <!-- main menu ... --> 
<TABLE width="100%" border="0" cellspacing="0" cellpadding="0">
  <TBODY>
  <TR>
    <TD bgcolor="#57a7ea">
      <TABLE border="0" cellspacing="0" cellpadding="0">
        <TBODY>
        <TR>
          <TD><A href="http://algolist.manual.ru/"><IMG width="140" height="17" 
            alt=":: алгоритмы  и методы ::" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/bs0.gif" 
            border="0"></A></TD>
          <TD><A href="http://algolist.manual.ru/olimp/"><IMG width="140" 
            height="17" alt=":: олимпиадные задачи ::" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/bs1.gif" 
            border="0"></A></TD>
          <TD><A href="http://algolist.manual.ru/contact.php"><IMG width="47" 
            height="17" alt=":: связь ::" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/bs2.gif" 
            border="0"></A></TD>
          <TD><A href="http://algolist.manual.ru/aboutsite.php"><IMG width="57" 
            height="17" alt=":: о сайте ::" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/bs3.gif" 
            border="0"></A></TD><!--	<td><img onclick="window.location='http://forum.algolist.ru/'" style="cursor:pointer" src="/img/bs6.gif" width=49 height=17 border=0 alt=":: форум ::"></td> --> <!--        <td><a href="/links/"><img src="/img/bs5.gif" width=57 height=17 border=0 alt=":: ссылки ::"></a></td>--> 
                  </TR></TBODY></TABLE></TD></TR>
  <TR>
    <TD bgcolor="#ffffff"><IMG width="1" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"></TD></TR></TBODY></TABLE><!-- ...main menu --> <!-- path line... --> 
<TABLE width="100%" bgcolor="#dddddd" border="0" cellspacing="2" 
cellpadding="2">
  <TBODY>
  <TR>
    <TD style="white-space: nowrap;"><B>Путь:  <A href="http://algolist.manual.ru/ds/">Структуры 
      данных</A> » <A href="http://algolist.manual.ru/ds/basic/">Введение в 
      абстрактные структуры</A> » </B></TD></TR></TBODY></TABLE><!-- ...path line --> <!-- 
==============
 MAIN CONTENT:
==============
--> <!-- табличка для создания отступов... --> 
<TABLE width="100%" border="0" cellspacing="0" cellpadding="12">
  <TBODY>
  <TR>
    <TD>
      <TABLE width="100%" border="0" cellspacing="0" cellpadding="0">
        <TBODY>
        <TR>
          <TD colspan="2"><FONT color="#333333" face="Arial" 
            size="4"><B>&nbsp; Реализация односвязного и двусвязного 
            списков</B></FONT></TD></TR>
        <TR>
          <TD bgcolor="#999999" colspan="2"><IMG width="1" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD></TR>
        <TR valign="top">
          <TD align="center"><IMG width="160" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD>
          <TD width="100%"><BR>
            <P align="right"><I>По изданию "Модели и структуры 
            данных"<BR>Alexander S. Derevjanko</I></P>
            <P>Ниже рассматриваются некоторые простые операции над линейными  
            списками.  Выполнение  операций иллюстрируется в общем случае 
            рисунками со схемами изменения связей и программными примерами. </P>
            <P>На всех рисунках сплошными линиями показаны связи, имевшиеся до 
            выполнения и сохранившиеся после выполнения операции.  Пунктиром 
            показаны связи, установленные при выполнении операции. Значком 'x' 
            отмечены связи,  разорванные при выполнении операции.  Во всех  
            операциях  чрезвычайно  важна  последовательность коррекции 
            указателей,  которая обеспечивает корректное изменение списка, не 
            затрагивающее другие элементы. При неправильном порядке коррекции 
            легко потерять часть списка. Поэтому на рисунках рядом с 
            устанавливаемыми  связями в скобках показаны шаги,  на которых эти 
            связи устанавливаются. </P>
            <P>В программных примерах подразумеваются определенными следующие 
            типы данных: 
            <UL>
              <LI>любая структура информационной части списка:<BR>
<PRE class="source">type data = ...; </PRE>
              <LI>элемент односвязного списка (sll - single linked list): 
<PRE class="source"> type
   sllptr = ^slltype; { указатель в односвязном списке }
   slltype = record { элемент односвязного списка }
     inf : data;    { информационная часть }
     next : sllptr; { указатель на следующий элемент }
     end;
</PRE>
              <LI>элемент двухсвязного списка (dll - double linked list): 
<PRE class="source"> type
   dllptr = ^dlltype;     { указатель в двухсвязном списке }
   dlltype = record { элемент односвязного списка }
     inf : data;    { информационная часть }
     next : dllptr; { указатель на следующий элемент (вперед) }
     prev : dllptr; { указатель на предыдущий элемент (назад) }
     end;
</PRE></LI></UL>
            <P></P></TD></TR>
        <TR>
          <TD colspan="2"><FONT color="#4b5d70" face="Arial" 
            size="3"><B><BR>&nbsp; Перебор элементов списка</B></FONT></TD></TR>
        <TR>
          <TD bgcolor="#999999" colspan="2"><IMG width="1" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD></TR>
        <TR valign="top">
          <TD align="center"><IMG width="160" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD>
          <TD width="100%"><BR>
            <P>Эта операция, возможно, чаще других выполняется над линейными 
            списками.  При ее  выполнении  осуществляется  последовательный 
            доступ к элементам списка - ко всем до конца списка или до 
            нахождения искомого элемента. </P>
            <P>Алгоритм перебора  для  односвязного  списка  представляется 
            программным примером 1. </P>
<PRE class="source"> {==== Программный пример 1 ====}
 { Перебор 1-связного списка }
 Procedure LookSll(head : sllptr);
  { head - указатель на начало списка }
  var cur : sllptr;  { адрес текущего элемента }
   begin
   cur:=head; { 1-й элемент списка назначается текущим }
   while cur &lt;&gt; nil do begin   &lt; обработка c^.inf &gt;
   </PRE>обрабатывается 
            информационная часть того эл-та, на который указывает cur. Обработка 
            может состоять в: 
            <UL>
              <LI>печати содержимого инф.части; 
              <LI>модификации полей инф.части; 
              <LI>сравнения полей инф.части с образцом при поиске по ключу; 
              <LI>подсчете итераций цикла при поиске по номеру; 
              <LI>и т.д., и т.п. </LI></UL>
<PRE class="source">     cur:=cur^.next;</PRE>из текущего эл-та 
            выбирается указатель на следующий эл-т и для следующей итерации 
            следующий эл-т становится текущим; если текущий эл-т был последний, 
            то его поле next содержит пустой указатель и, т.обр. в cur запишется 
            nil, что приведет к выходу из цикла при проверке условия while 
<PRE class="source">   end;  end;
  { конец примера } </PRE>
            <P>В двухсвязном списке возможен перебор как в прямом направлении 
            (он выглядит точно так же,  как и перебор в односвязном списке), так 
             и  в обратном.  В последнем случае параметром процедуры должен быть 
            tail - указатель на конец списка, и переход к следующему элементу 
            должен осуществляться по указателю назад: </P>
<PRE class="source">           cur:=cur^.prev;</PRE>
            <P>Алгоритм перебора для двусвязного списка мы оставляем читателю на 
            самостоятельную разработку. </P></TD></TR>
        <TR>
          <TD colspan="2"><FONT color="#4b5d70" face="Arial" 
            size="3"><B><BR>&nbsp; Вставка элемента в список</B></FONT></TD></TR>
        <TR>
          <TD bgcolor="#999999" colspan="2"><IMG width="1" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD></TR>
        <TR valign="top">
          <TD align="center"><IMG width="160" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD>
          <TD width="100%"><BR>
            <P>Вставка элемента в середину односвязного списка показана на рис.1 
            и в примере 2. </P>
            <DIV align="center"><IMG width="485" height="122" alt="Вставка элемента в середину 1-связного списка" 
            src="Реализация%20односвязного%20и%20двусвязного%20списков_files/simple_list1.gif" 
            border="0"></DIV>
            <CENTER><SMALL><B>Рис. 1</B>:&nbsp;Вставка элемента в середину 
            1-связного списка</SMALL></CENTER><BR>
<PRE class="source">  {==== Программный пример 2 ====}
 { Вставка элемента в середину 1-связного списка }
 Procedure InsertSll(prev : sllptr; inf : data);
 { prev - адрес предыдущего эл-та; inf - данные нового эл-та }
  var cur : sllptr;  { адрес нового эл-та }
   begin
   { выделение памяти для нового эл-та и запись в его инф.часть }
   New(cur); cur^.inf:=inf;
   cur^.next:=prev^.next; { эл-т, следовавший за предыдущим теперь
 будет следовать за новым }
   prev^.next:=cur;       { новый эл-т следует за предыдущим }
 end;
 </PRE>
            <P>Рисунок 2 представляет вставку в двухсвязный список. </P>
            <DIV align="center"><IMG width="606" height="208" alt="Вставка элемента в середину 2-связного списка" 
            src="Реализация%20односвязного%20и%20двусвязного%20списков_files/simple_list2.gif" 
            border="0"></DIV>
            <CENTER><SMALL><B>Рис. 2</B>:&nbsp;Вставка элемента в середину 
            2-связного списка</SMALL></CENTER><BR>
            <P>Приведенные примеры обеспечивают вставку в  середину списка, но 
            не могут быть применены для вставки в начало списка. При последней 
            должен модифицироваться указатель на  начало  списка,  как показано 
            на рис. 3. </P>
            <DIV align="center"><IMG width="295" height="122" alt="Вставка элемента в начало 1-связного списка" 
            src="Реализация%20односвязного%20и%20двусвязного%20списков_files/simple_list3.gif" 
            border="0"></DIV>
            <CENTER><SMALL><B>Рис. 3</B>:&nbsp;Вставка элемента в начало 
            1-связного списка</SMALL></CENTER><BR>
            <P>Программный пример 3 представляет  процедуру,  выполняющую 
            вставку элемента в любое место односвязного списка.</P>
<PRE class="source"> {==== Программный пример 3 ====}
 { Вставка элемента в любое место 1-связного списка }
 Procedure InsertSll
   var head : sllptr; { указатель на начало списка, может измениться в
 процедуре, если head=nil - список пустой }
       prev : sllptr; { указатель на эл-т, после к-рого делается вставка,
 если prev-nil - вставка перед 1-ым эл-том }
       inf : data { - данные нового эл-та }
  var cur : sllptr;  { адрес нового эл-та }
   begin
   { выделение памяти для нового эл-та и запись в его инф.часть }
   New(cur); cur^.inf:=inf;
   if prev &lt;&gt; nil then begin { если есть предыдущий эл-т - вставка в
 середину списка, см. прим. 2 }
     cur^.next:=prev^.next;  prev^.next:=cur;
     end
   else begin { вставка в начало списка }
     cur^.next:=head; { новый эл-т указывает на бывший 1-й эл-т списка;
 если head=nil, то новый эл-т будет и последним эл-том списка }
     head:=cur; { новый эл-т становится 1-ым в списке, указатель на
 начало теперь указывает на него }
  end; end;
</PRE></TD></TR>
        <TR>
          <TD colspan="2"><FONT color="#4b5d70" face="Arial" 
            size="3"><B><BR>&nbsp; Удаление элемента из списка</B></FONT></TD></TR>
        <TR>
          <TD bgcolor="#999999" colspan="2"><IMG width="1" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD></TR>
        <TR valign="top">
          <TD align="center"><IMG width="160" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD>
          <TD width="100%"><BR>
            <P>Удаление элемента из односвязного списка показано на рис. 4. </P>
            <DIV align="center"><IMG width="399" height="224" alt="Удаление элемента из 1-связного списка" 
            src="Реализация%20односвязного%20и%20двусвязного%20списков_files/simple_list4.gif" 
            border="0"></DIV>
            <CENTER><SMALL><B>Рис. 4</B>:&nbsp;Удаление элемента из 1-связного 
            списка</SMALL></CENTER><BR>
            <P>Очевидно, что  процедуру удаления легко выполнить,  если известен 
            адрес элемента,  предшествующего удаляемому (prev на  рис.4.а). Мы, 
            однако, на рис. 4 и в примере 1 приводим процедуру  для  случая,  
            когда  удаляемый элемент задается своим адресом (del на рис.4).  
            Процедура обеспечивает удаления как из середины, так и из начала 
            списка. </P>
<PRE class="source"> {==== Программный пример 1 ====}
 { Удаление элемента из любого места 1-связного списка }
 Procedure DeleteSll(
   var head : sllptr; { указатель на начало списка, может
                        измениться в процедуре }
       del : sllptr   { указатель на эл-т, к-рый удаляется }  );
  var prev : sllptr;  { адрес предыдущего эл-та }
   begin
   if head=nil then begin { попытка удаления из пустого списка 
   асценивается как ошибка (в последующих примерах этот случай 
   учитываться на будет) }
       Writeln('Ошибка!'); Halt;
       end;
   if del=head then { если удаляемый эл-т - 1-й в списке, то 
следующий за ним становится первым }
     head:=del^.next
   else begin { удаление из середины списка }
  
 { приходится искать эл-т, предшествующий удаляемому;
 поиск производится перебором списка с самого его начала,
 пока не будет найдет эл-т, поле next к-рого совпадает
 с адресом удаляемого элемента. }

     prev:=head^.next;
     while (prev^.next&lt;&gt;del) and (prev^.next&lt;&gt;nil) do
       prev:=prev^.next;
     if prev^.next=nil then begin
   { это случай, когда перебран весь список, но эл-т не найден,
   он отсутствует в списке; расценивается как ошибка 
   (в последующих примерах этот случай учитываться на будет)
       Writeln('Ошибка!'); Halt;
       end;
     prev^.next:=del^.next;
   { предыдущий эл-т теперь указывает
   на следующий за удаляемым }
     end;
   { элемент исключен из списка, теперь можно освободить 
занимаемую им память }
   Dispose(del);
 end;
 </PRE>
            <P>На практике в односвязных списках используется преимущественно 
            операция удаления элемента, следующего за данным, так как проход по 
            всему списку - слишком дорогостоящая операция. Получается, также, 
            что мы не можем быстро удалить текущий элемент. Такую операцию 
            допускает лишь двусвязный список. Удаление элемента  из двухсвязного 
            списка показано на рис.5.</P>
            <DIV align="center"><IMG width="567" height="137" alt="Удаление элемента из 2-связного списка" 
            src="Реализация%20односвязного%20и%20двусвязного%20списков_files/simple_list5.gif" 
            border="0"></DIV>
            <CENTER><SMALL><B>Рис. 5</B>:&nbsp;Удаление элемента из 2-связного 
            списка</SMALL></CENTER><BR>
            <P>Процедуру удаления  элемента из двухсвязного списка окажется даже 
            проще,  чем для односвязного,  так как в ней не нужен  поиск 
            предыдущего элемента, он выбирается по указателю назад. </P></TD></TR>
        <TR>
          <TD colspan="2"><FONT color="#4b5d70" face="Arial" 
            size="3"><B><BR>&nbsp; Перестановка элементов  
        списка.</B></FONT></TD></TR>
        <TR>
          <TD bgcolor="#999999" colspan="2"><IMG width="1" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD></TR>
        <TR valign="top">
          <TD align="center"><IMG width="160" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD>
          <TD width="100%"><BR>
            <P>Изменчивость   динамических структур данных предполагает не 
            только изменения размера структуры,  но и изменения связей между 
            элементами. Для связных структур изменение  связей не требует 
            пересылки данных в памяти,  а только изменения указателей в 
            элементах связной  структуры.  В  качестве примера приведена 
            перестановка двух соседних элементов списка.  В алгоритме 
            перестановки в односвязном списке (рис.6, пример 2) исходили  из 
            того,  что известен адрес элемента,  предшествующего паре, в которой 
            производится перестановка. В приведенном алгоритме  также  не  
            учитывается  случай перестановки первого и второго элементов. </P>
            <DIV align="center"><IMG width="544" height="83" alt="Перестановка соседних элементов 1-связного списка" 
            src="Реализация%20односвязного%20и%20двусвязного%20списков_files/simple_list6.gif" 
            border="0"></DIV>
            <CENTER><SMALL><B>Рис. 6</B>:&nbsp;Перестановка соседних элементов 
            1-связного списка</SMALL></CENTER><BR>
<PRE class="source"> {==== Программный пример 2 ====}
 { Перестановка двух соседних элементов в 1-связном списке }
 Procedure ExchangeSll(
       prev : sllptr   { указатель на эл-т, предшествующий
 переставляемой паре }  );
  var p1, p2 : sllptr;  { указатели на эл-ты пары }
   begin
   p1:=prev^.next;     { указатель на 1-й эл-т пары }
   p2:=p1^.next;       { указатель на 2-й эл-т пары }
   p1^.next:=p2^.next; { 1-й элемент пары теперь указывает на
     следующий за парой }
   p2^.next:=p1;       { 1-й эл-т пары теперь следует за 2-ым }
   prev^.next:=p2;     { 2-й эл-т пары теперь становится 1-ым }
 end;
 </PRE>
            <P>В процедуре перестановки для двухсвязного списка (рис.7.) 
            нетрудно учесть и перестановку в начале/конце списка.</P></TD></TR>
        <TR>
          <TD colspan="2"><FONT color="#4b5d70" face="Arial" 
            size="3"><B><BR>&nbsp; Копирование части списка</B></FONT></TD></TR>
        <TR>
          <TD bgcolor="#999999" colspan="2"><IMG width="1" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD></TR>
        <TR valign="top">
          <TD align="center"><IMG width="160" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD>
          <TD width="100%"><BR>
            <P>При  копировании  исходный  список сохраняется  в памяти,  и 
            создается новый список.  Информационные поля элементов нового списка 
            содержат те же данные,  что и в элементах  старого списка,  но поля 
            связок в новом списке совершенно другие,  поскольку элементы нового 
            списка расположены  по  другим адресам в памяти. Существенно, что 
            операция копирования предполагает дублирование данных в памяти.  
            Если после создания копии будут изменены данные в исходном списке,  
            то изменение не будет отражено в копии и наоборот. </P>
            <DIV align="center"><IMG width="525" height="292" alt="Перестановка соседних элементов 2-связного списка" 
            src="Реализация%20односвязного%20и%20двусвязного%20списков_files/simple_list7.gif" 
            border="0"></DIV>
            <CENTER><SMALL><B>Рис. 5</B>:&nbsp;Перестановка соседних элементов 
            2-связного списка</SMALL></CENTER><BR>
            <P>Копирование для  односвязного  списка показано в программном 
            примере 3.</P>
<PRE class="source"> {==== Программный пример 3 ====}
{ Копирование части 1-связного списка. head - указатель на 
начало копируемой части; num - число эл-тов. Ф-ция возвращает
указатель на список-копию }
 Function CopySll ( head : sllptr; num : integer) : sllptr;
  var cur, head2, cur2, prev2 : sllptr;
  begin
    if head=nil then { исходный список пуст - копия пуста }
      CopySll:=nil
    else begin
      cur:=head; prev2:=nil;
      { перебор исходного списка до конца или по счетчику num }
      while (num&gt;0) and (cur&lt;&gt;nil) do begin
  { выделение памяти для эл-та выходного списка и запись в него
 информационной части }
        New(cur2); cur2^.inf:=cur^.inf;
  { если 1-й эл-т выходного списка - запоминается указатель на
 начало, иначе - записывается указатель в предыдущий элемент }
        if prev2&lt;&gt;nil then prev2^.next:=cur2 else head2:=cur2;
        prev2:=cur2;  { текущий эл-т становится предыдущим }
        cur:=cur^.next;  { продвижение по исходному списку }
        num:=num-1;   { подсчет эл-тов }
        end;
      cur2^.next:=nil; { пустой указатель - в последний эл-т
 выходного списка }
      CopySll:=head2;  { вернуть указатель на начало вых.списка }
  end;   end;
</PRE></TD></TR>
        <TR>
          <TD colspan="2"><FONT color="#4b5d70" face="Arial" 
            size="3"><B><BR>&nbsp; Слияние двух списков</B></FONT></TD></TR>
        <TR>
          <TD bgcolor="#999999" colspan="2"><IMG width="1" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD></TR>
        <TR valign="top">
          <TD align="center"><IMG width="160" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD>
          <TD width="100%"><BR>
            <P>Операция слияния заключается в формировании из двух списков 
            одного - она аналогична операции  сцепления  строк.  В  случае 
            односвязного списка,  показанном в примере 4, слияние выполняется 
            очень просто.  Последний элемент первого списка содержит пустой 
            указатель на следующий элемент,  этот указатель служит признаком 
            конца списка. Вместо этого пустого указатель  в  последний  элемент 
            первого списка заносится указатель на начало второго списка.  Таким 
            образом,  второй список  становится продолжением первого. </P>
<PRE class="source"> {==== Программный пример 4 ====}
 { Слияние двух списков. head1 и head2 - указатели на начала
 списков. На результирующий список указывает head1 }
 Procedure Unite (var head1, head2 : sllptr);
  var cur : sllptr;
  begin          { если 2-й список пустой - нечего делать }
    if head2&lt;&gt;nil then begin
      { если 1-й список пустой, выходным списком будет 2-й }
    if head1=nil then head1:=head2
    else     { перебор 1-го списка до последнего его эл-та }
     begin  cur:=head1;
      while cur^.next&lt;&gt;nil do cur:=cur^.next;
      { последний эл-т 1-го списка указывает на начало 2-го }
      cur^.next:=head2;
     end;   head2:=nil; { 2-й список аннулируется }
   end; end;
</PRE></TD></TR>
        <TR>
          <TD colspan="2"><FONT color="#4b5d70" face="Arial" 
            size="3"><B><BR>&nbsp; Применение линейных списков</B></FONT></TD></TR>
        <TR>
          <TD bgcolor="#999999" colspan="2"><IMG width="1" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD></TR>
        <TR valign="top">
          <TD align="center"><IMG width="160" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD>
          <TD width="100%"><BR>
            <P>Линейные списки находят широкое применение в приложениях, где 
            непредсказуемы требования на размер памяти,  необходимой для 
            хранения данных; большое число сложных операций над данными, 
            особенно включений и исключений. На базе линейных списков могут 
            строится  стеки,  очереди  и  деки.  Представление  очереди  с  
            помощью линейного списка позволяет достаточно просто обеспечить 
            любые желаемые дисциплины обслуживания очереди. Особенно это удобно, 
            когда число элементов в очереди трудно предсказуемо.</P>
            <P>В программном примере 5 показана организация стека на односвязном 
            линейном  списке. Стек представляется как линейный список, в котором 
            включение элементов  всегда  производятся  в начала списка,  а 
            исключение - также из начала.  Для представления его нам достаточно 
            иметь один указатель - top, который всегда указывает на последний 
            записанный в стек элемент. В исходном состоянии (при пустом стеке) 
            указатель top - пустой. Процедуры StackPush и StackPop сводятся к 
            включению и исключению элемента в начало списка.</P>
            <P>Обратите внимание, что при включении элемента для него выделяется 
            память, а при исключении - освобождается. Перед включением  элемента 
             проверяется  доступный объем памяти,  и  если он не позволяет 
            выделить память для нового элемента, стек считается заполненным.  
            При очистке стека последовательно просматривается весь список и 
            уничтожаются его элементы. При списковом представлении стека 
            оказывается непросто определить размер стека.  Эта  операция  могла 
            бы потребовать перебора всего списка с подсчета числа элементов.  
            Чтобы избежать последовательного перебора  всего  списка  мы  ввели 
            дополнительную переменную stsize, которая отражает текущее число 
            элементов в стеке  и  корректируется при каждом 
            включении/исключении. </P>
<PRE class="source"> {==== Программный пример 5 ====}
 { Стек на 1-связном линейном списке }
 unit Stack;
 Interface
 type data = ...; { эл-ты могут иметь любой тип }
 Procedure StackInit;
 Procedure StackClr;
 Function StackPush(a : data) : boolean;
 Function StackPop(Var a : data) : boolean;
 Function StackSize : integer;
 Implementation
 type stptr = ^stit;  { указатель на эл-т списка }
      stit = record   { элемент списка }
        inf : data;   { данные }
        next: stptr;  { указатель на следующий эл-т }
        end;
 Var top : stptr; { указатель на вершину стека }
     stsize : longint;  { размер стека }
 {** инициализация - список пустой }
 Procedure StackInit;
   begin   top:=nil; stsize:=0;  end; { StackInit }
 {** очистка - освобождение всей памяти }
 Procedure StackClr;
  var x : stptr;
   begin   { перебор эл-тов до конца списка и их уничтожение }
   while top&lt;&gt;nil do
     begin  x:=top; top:=top^.next; Dispose(x);  end;
   stsize:=0;
 end; { StackClr }
 Function StackPush(a: data) : boolean;   { занесение в стек }
  var x : stptr;
   begin      { если нет больше свободной памяти - отказ }
   if MaxAvail &lt; SizeOf(stit) then StackPush:=false
   else   { выделение памяти для эл-та и заполнение инф.части }
     begin  New(x); x^.inf:=a;
                { новый эл-т помещается в голову списка }
       x^.next:=top; top:=x;
       stsize:=stsize+1; { коррекция размера }
       StackPush:=true;
     end;
 end; { StackPush }
 Function StackPop(var a: data) : boolean; { выборка из стека }
  var x : stptr;
   begin
   { список пуст - стек пуст }
   if top=nil then StackPop:=false
   else begin
     a:=top^.inf; { выборка информации из 1-го эл-та списка }
     { 1-й эл-т исключается из списка, освобождается память }
     x:=top; top:=top^.next; Dispose(top);
     stsize:=stsize-1; { коррекция размера }
     StackPop:=true;
 end;  end; { StackPop }
 Function StackSize : integer;  { определение размера стека }
   begin   StackSize:=stsize;   end; { StackSize }
 END.
</PRE>
            <P>Программный пример для организация на  односвязном  линейном 
            списке очереди  FIFO  разработайте самостоятельно.  Для линейного 
            списка,  представляющего очередь, необходимо будет сохранять: top - 
            на первый элемент списка, и bottom - на последний элемент. </P>
            <P>Линейные связные  списки иногда используются также для 
            представления таблиц - в тех случаях,  когда размер таблицы может  
            существенно изменяться в процессе ее существования. Однако, то 
            обстоятельство,  что доступ к элементам  связного  линейного  списка 
            может быть только последовательным,  не позволяет применить к такой 
            таблице эффективный двоичный поиск, что существенно ограничивает их 
            применимость.  Поскольку упорядоченность такой таблицы не может 
            помочь в  организации  поиска,  задачи  сортировки  таблиц, 
            представленных линейными связными списками, возникают значительно 
            реже, чем для таблиц в векторном представлении. Однако, в некоторых  
            случаях  для таблицы,  хотя и не требуется частое выполнение поиска, 
             но задача генерации отчетов требует расположения записей таблицы в 
            некотором порядке. Некоторые  алгоритмы,  возможно,  потребуют 
            каких-либо усложнений структуры,  например, быструю сортировку Хоара 
            целесообразно проводить только на двухсвязном списке, в цифровой 
            сортировке удобно создавать промежуточные списке для цифровых групп 
            и т.д. Мы приведем два  простейших  примера  сортировки  
            односвязного  линейного списка. В обоих случаях мы предполагаем, что 
            определены типы данных: </P>
<PRE class="source">     type lptr = ^item; { указатель на элемент списка }
          item = record    { элемент списка }
            key : integer; { ключ }
            inf : data;    { данные }
            next: lptr;    { указатель на элемент списка }
            end;
</PRE>
            <P>В обоих случаях сортировка ведется по возрастанию  ключей.  В 
            обоих случаях параметром функции сортировки является указатель на 
            начало неотсортированного списка, функция возвращает указатель на 
            начало отсортированного списка. Прежний,  несортированный список 
            перестает существовать.</P>
            <P>Пример 6 демонстрирует сортировку выборкой. Указатель newh 
            является указателем на начало выходного списка,  исходно - пустого. 
            Во входном списке ищется максимальный элемент. Найденный элемент  
            исключается из входного списка и включается в начало выходного 
            списка. Работа алгоритма заканчивается, когда входной список станет 
            пустым.  Обратим внимание читателя на несколько особенностей 
            алгоритма.  Во-первых, во входном списке ищется всякий раз не 
            минимальный, а максимальный элемент. Поскольку элемент включается в 
            начало выходного списка, элементы с большими ключами оттесняются к 
            концу выходного списка и  последний,  таким  образом, оказывается 
            отсортированным по возрастанию ключей. Во-вторых, при поиске во 
            входном списке сохраняется не только  адрес  найденного элемента  в 
            списке,  но и адрес предшествующего ему в списке эле- мента - это 
            впоследствии облегчает исключение элемента  из списка (вспомните 
            пример 1). В-третьих, обратите внимание на то, что у нас не 
            возникает никаких проблем с пропуском  во  входном  списке тех  
            элементов,  которые  уже  выбраны  - они просто исключены из входной 
            структуры данных. </P>
<PRE class="source"> {==== Программный пример 6 ====}
 { Сортировка выборкой на 1-связном списке }
 Function Sort(head : lptr) : lptr;
  var newh, max, prev, pmax, cur : lptr;
   begin        newh:=nil;         { выходной список - пустой }
   while head&lt;&gt;nil do { цикл, пока не опустеет входной список }
     begin   max:=head; prev:=head; { нач.максимум - 1-й эл-т }
     cur:=head^.next;     { поиск максимума во входном списке }
     while cur&lt;&gt;nil do begin
       if cur^.key&gt;max^.key then begin
{ запоминается адрес максимума и адрес предыдущего эл-та }
         max:=cur; pmax:=prev;
     end;    prev:=cur; cur:=cur^.next; { движение по списку }
       end;        { исключение максимума из входного списка }
     if max=head then head:=head^.next
     else pmax^.next:=max^.next;
     { вставка в начало выходного списка }
     max^.next:=newh; newh:=max;
   end;  Sort:=newh;
  end;
  </PRE>
            <P>В программном примере 7 - иллюстрации сортировки вставками - из 
            входного списка выбирается (и исключается) первый элемент и 
            вставляется в выходной список "на свое место" в соответствии со 
            значениями ключей. Обратите внимание на то, что в двух последних 
            примерах пересылок данных не происходит, все записи таблиц остаются 
            на своих местах в памяти, меняются только связи между ними - 
            указатели. </P>
<PRE class="source"> {==== Программный пример 7 ====}
 { Сортировка вставками на 1-связном списке }
 type data = integer;
 Function Sort(head : lptr) : lptr;
  var newh, cur, sel : lptr;
   begin
   newh:=nil;  { выходной список - пустой }
   while head &lt;&gt; nil do begin { цикл, пока не опустеет входной список }
     sel:=head;  { эл-т, который переносится в выходной список }
     head:=head^.next;         { продвижение во входном списке }
     if (newh=nil) or (sel^.key &lt; newh^.key) then begin
{выходной список пустой или элемент меньше 1-го-вставка в начало}
     sel^.next:=newh; newh:=sel;   end
     else begin                { вставка в середину или в конец }
       cur:=newh;
{ до конца выходного списка или пока ключ следующего эл-та не будет
 больше вставляемого }
       while (cur^.next &lt;&gt; nil) and (cur^.next^.key &lt; sel^.key) do
         cur:=cur^.next;
       { вставка в выходной список после эл-та cur }
       sel^.next:=cur^.next;    cur^.next:=sel;
      end;   end;   Sort:=newh;
  end;
 </PRE></TD></TR>
        <TR>
          <TD colspan="2"><FONT color="#4b5d70" face="Arial" 
            size="3"><B><BR>&nbsp; Мультисписки</B></FONT></TD></TR>
        <TR>
          <TD bgcolor="#999999" colspan="2"><IMG width="1" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD></TR>
        <TR valign="top">
          <TD align="center"><IMG width="160" height="1" src="Реализация%20односвязного%20и%20двусвязного%20списков_files/0.gif"><BR></TD>
          <TD width="100%"><BR>
            <P>В программных  системах,  обрабатывающих   объекты   сложной 
            структуры, могут  решаться  разные  подзадачи,  каждая из которых 
            требует, возможно,  обработки не всего множества объектов, а лишь 
            какого-то его подмножества.  Так,  например, в автоматизированной 
            системе учета лиц, пострадавших вследствие аварии на ЧАЭС, каждая 
            запись об  одном пострадавшем содержит более 50 полей в своей 
            информационной части. Решаемые же автоматизированной системой задачи 
            могут потребовать выборки, например: 
            <UL>
              <LI>участников ликвидации аварии; 
              <LI>переселенцев из зараженной зоны; 
              <LI>лиц, состоящих на квартирном учете; 
              <LI>лиц с заболеваниями щитовидной железы; 
              <LI>и т.д., и т.п. </LI></UL>
            <P></P>
            <DIV align="center"><IMG width="398" height="438" alt="Пример мультисписка" 
            src="Реализация%20односвязного%20и%20двусвязного%20списков_files/simple_list8.gif" 
            border="0"></DIV>
            <CENTER><SMALL><B>Рис. 8</B>:&nbsp;Пример 
            мультисписка</SMALL></CENTER><BR>
            <P>Для того,  чтобы  при выборке каждого подмножества не выполнять 
            полный просмотр с отсеиванием записей,  к требуемому подмножеству не 
            относящихся,  в каждую запись включаются дополнительные поля ссылок, 
             каждое из которых связывает в линейный список  элементы 
            соответствующего подмножества. В результате получается многосвязный 
            список или мультисписок,  каждый элемент которого может входить 
            одновременно в несколько односвязных списков.  Пример такого 
            мультисписка для названной нами  автоматизированной  системы показан 
            на рис.8. </P>
            <P>К достоинствам мультисписков  помимо  экономии  памяти  (при 
            множестве списков  информационная часть существует в единственном 
            экземпляре) следует отнести также  целостность  данных  -  в  том 
            смысле, что  все  подзадачи работают с одной и той же версией 
            информационной части и изменения в данных, сделанные одной 
            подзадачей немедленно становятся доступными для другой подзадачи. 
            </P>
            <P>Каждая подзадача работает со своим подмножеством как  с  линейным 
            списком,  используя  для  этого  определенное поле связок. Специфика 
            мультисписка проявляется только в  операции  исключения элемента из  
            списка.  Исключение  элемента  из какого-либо одного списка еще не 
            означает необходимости удаления элемента из памяти, так как элемент 
            может оставаться в составе других списков. Память должна 
            освобождаться только в том случае,  когда элемент  уже  не входит ни 
             в один из частных списков мультисписка.  Обычно задача удаления 
            упрощается тем,  что один из  частных  списков  является главным - в 
            него обязательно входят все имеющиеся элементы. Тогда исключение 
            элемента из любого неглавного списка состоит  только в 
            переопределении указателей, но не в освобождении памяти. Исключение 
            же из главного списка требует не только  освобождения памяти, но и  
            переопределения  указателей как в главном списке,  так и во всех 
            неглавных списках, в которые удаляемый элемент входил. 
        </P><BR></TD></TR></TBODY></TABLE>
      <HR>
<!-- ...табличка для создания отступов--> 
<SCRIPT type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2056213-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</SCRIPT>
       <!-- Yandex.Metrika counter --> 
<SCRIPT type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21593104 = new Ya.Metrika({id:21593104,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</SCRIPT>
       <NOSCRIPT>&lt;div&gt;&lt;img src="//mc.yandex.ru/watch/21593104" 
      style="position:absolute; left:-9999px;" alt="" 
      /&gt;&lt;/div&gt;</NOSCRIPT> <!-- /Yandex.Metrika counter --> 
</TR></TBODY></TABLE></BODY></HTML>
